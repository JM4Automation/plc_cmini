#include "Arduino.h" 
#include "jm4a_cmini.h" 
#include <avr/interrupt.h> 
#include "jm4a_01.h" 
#include"jm4a_02.h" 
#include "jm4a_03.h" 
#include <stdlib.h> 
uint8_t F01[8] = {14, 15, 16, 17, 20, 21, 2, 3}; uint8_t F02[8] = {4, 5, 6, 7, 8, 9, 18, 19}; uint8_t F03[6] = {10, 10, 10, 10, 10, 10}; bool F04[4] = {0,0,0,0}; bool F05[3] = {0,0,0}; bool F06[3] = {0,0,0}; bool F07[2] = {0,0}; volatile int F08[8] = {0, 0, 0, 0, 0, 0, 0, 0}; volatile int F09[8] = {0, 0, 0, 0, 0, 0, 0, 0}; volatile int F10[8] = {0, 0, 0, 0, 0, 0, 0, 0}; volatile int F11[8] = {0, 0, 0, 0, 0, 0, 0, 0}; volatile char F12[2] = {'a','z'}; volatile char F13[2] = {'z','a'}; volatile uint8_t F14 = 0; volatile bool F15 = false; bool F16 = false; bool F17 = false; bool F18 = false; volatile uint32_t F19 = 0; volatile uint16_t F20 = 0; char F21 = 'A'; const char* F22 = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz"; jm4a_cmini::jm4a_cmini() { } void jm4a_cmini::begin(unsigned long f) { F53.F54(f); F85(0); for (uint8_t i = 0; i < 8; i++) { F46.F41(F01[i], 0); F46.F41(F02[i], 1); } } void jm4a_cmini::dataTransfer() { if (F17 == false) { F23(); } if (F16 == false) { F27(); } } void jm4a_cmini::F23() { if (F53.F54()) { char a[32]; uint8_t b =F53.F55('\n', a, sizeof(a) - 1); while (F53.F54()) { F53.F58();  } if(a[0] != F21 || a[b - 1] != ';'){ F85(1); return;       } if (a[1] == '>') { F24(a,b); return; } if (a[1] == '*') { F34(a,b); return; } } } void jm4a_cmini::F24(char* f, uint8_t ff){ if (ff == 14) { for (uint8_t i = 2; i < 10; i++) { F11[i - 2] = f[i] - '0'; } F12[0] = f[ff - 2]; F12[1] = f[ff - 3]; } else if (ff > 14) { uint8_t k = 0; for (uint8_t i = 2; i < ff; i++) { if (f[i] == ':') {                   break; } else if (f[i] == '.') { continue; } else if (f[i] == ',') { if (f[i + 2] == ',' || f[i + 2] == '.') { F11[k] = f[i + 1] - '0'; i = i + 1; } else if (f[i + 3] == ',' || f[i + 3] == '.') { F11[k] = ((f[i + 1] - '0') *10) + f[i + 2] - '0'; i = i + 2; } else if (f[i + 4] == ',' || f[i + 4] == '.') { F11[k] = ((f[i + 1] - '0') *100) + ((f[i + 2] - '0') *10) + f[i + 3] - '0'; i = i + 3; } else if (f[i + 5] == ',' || f[i + 5] == '.') { F11[k] = ((f[i + 1] - '0') *1000) + ((f[i + 2] - '0') *100) + ((f[i + 3] - '0') *10) + f[i + 4] - '0'; i = i + 4; } } else { F11[k] = f[i] - '0'; } k++; if(k>8){ F85(2); break; } } F12[0] = f[ff - 2]; F12[1] = f[ff - 3]; } else{ F85(3); return; } F25(F11,8); if (F13[1] == F12[1] && F13[0] == F12[0]) { F26(); } else { F85(4); } } void jm4a_cmini::F25(int* f, uint8_t ff) { F14 = 0; uint8_t c = 0x00; for ( uint8_t i = 0; i < ff; i++) { c ^= f[i]; for (uint8_t j = 0; j < 8; j++) { if (c & 0x80) c = (c << 1) ^ 0x07; else c <<= 1; } } F14 = c; uint8_t a = F14 / 62; uint8_t b  = F14 % 62; F13[1] = F22[a]; F13[0] = F22[b];  } void jm4a_cmini::F26(){ memcpy(F10, F11, sizeof(F11)); F30(0); F30(3); F30(4); F30(6); F30(7); if (!F05[0]) { F30(1); } else { if(!F06[0]){ F31(1); } } if (!F05[1]) { F30(2); } else { if(!F06[1]){ F31(2); } } if (!F05[2]) { F30(5); } else { if(!F06[2]){ F31(5); } } if (F18) { F33("="); } } void jm4a_cmini::F27() { F15 = false; for (uint8_t i = 0; i < 4; i++) { if (!F04[i]) { F28(i); } else { F29(i); } } for (uint8_t i = 4; i < 6; i++) { F29(i); } for (uint8_t i = 6; i < 8; i++) { F28(i); } if (F15 == true) { F32(); } } void jm4a_cmini::F28(uint8_t f){ F08[f] = F46.F42(F01[f]); if (F09[f] != F08[f]) { F09[f] = F08[f]; F15 = true; } } void jm4a_cmini::F29(uint8_t f){ F08[f] = F46.F44(F01[f]); if (F09[f] + F03[f] <= F08[f] || F09[f] - F03[f] >= F08[f]) { F09[f] = F08[f]; F15 = true; } } void jm4a_cmini::F30(uint8_t f){ F46.F43(F02[f], F10[f]); } void jm4a_cmini::F31(uint8_t f){ F46.F45(F02[f], F10[f]); } void jm4a_cmini::F32(){ F25(F08,8); F47 f = ""; f.F48(">"); for (uint8_t i = 0; i < 4; i++) { if (!F04[i]) { f.F48(F08[i]); } else { if (i == 0) { f.F48(","); } else if (!F04[i - 1]) { f.F48(","); } if (i == 3) { f.F48(F08[i]); break; } f.F48(F08[i]); if (F04[i + 1]) { f.F48(","); } else { f.F48("."); } } } f.F48(","); f.F48(F08[4]); f.F48(","); f.F48(F08[5]); f.F48("."); for (uint8_t i = 6; i < 8; i++) { f.F48(F08[i]); } f.F48(":"); f.F48(F13[1]); f.F48(F13[0]); F33(f.F49()); } void jm4a_cmini::F33(F47 f){ F47 a = ""; a.F48(F21); a.F48(f); a.F48(";"); F53.F56(a.F49()); F53.F57(); } void jm4a_cmini::F34(char* f, uint8_t ff){ if(f[2]=='P'){ if(f[3]=='F'){ F37(f,ff); return; }else if(f[3]=='D'){ F35(f,ff); return; }else{ F85(5); return; } }else{ F85(5); return; } } void jm4a_cmini::F35(char* f, uint8_t ff){ float a; uint8_t k = 0; uint8_t r = 7; uint8_t b; if(f[6]=='/'){ b = ((f[4]- '0') *10)+f[5]-'0'; if(b!=5 && b!=1 && b!=2){ F85(6); return; } }else{ F85(2); return; } for(uint8_t i = 7; i<ff; i++){ if(f[i+1]==':'){ k=i; break; } } char c[(k-r)+2]; for(uint8_t i=0; i<(k-r)+1; i++){ c[i]=f[r+i]; } c[(k-r)+1] = '\0'; a = atof(c); int d = floor(a); int e[1] = { static_cast<int>(d) }; F25(e,1); F12[0] = f[ff - 2]; F12[1] = f[ff - 3]; if (F13[1] == F12[1] && F13[0] == F12[0]){ F36(b,a); }else{ F85(4); } } void jm4a_cmini::F36(uint8_t f, float ff) { if(f==5 && F06[2]){ OCR1A = (uint32_t)((float)F19 * (ff / 100.0)); return; }else if(f==1 && F06[0]){ if(ff<0.1){ if(F07[0]==true){ TCCR0A &= ~((1 << COM0B1) | (1 << COM0B0)); F07[0]=false; } F10[f]=0; F30(f); }else if(ff>99.9){ if (F07[0]==true) { TCCR0A &= ~((1 << COM0B1) | (1 << COM0B0));   F07[0] = false; } F10[f]=1; F30(f);   }else{ if(F07[0]==false){ TCCR0A |= (1 << COM0B1); TCCR0A &= ~(1 << COM0B0); F07[0]=true; } OCR0B = (uint8_t)((ff / 100.0) * 255); } }else if(f==2 && F06[1]){ if(ff<0.1){ if(F07[1]==true){ TCCR0A &= ~((1 << COM0A1) | (1 << COM0A0));  F07[1]=false; } F10[f]=0; F30(f); }else if(ff>99.9){ if (F07[1]==true) { TCCR0A &= ~((1 << COM0A1) | (1 << COM0A0));  F07[1] = false; } F10[f]=1; F30(f);  }else{ if(F07[1]==false){ TCCR0A |= (1 << COM0A1); TCCR0A &= ~(1 << COM0A0); F07[1]=true; } OCR0A = (uint8_t)((ff / 100.0) * 255); } }else{ F85(7); return; } } void jm4a_cmini::F37(char* f, uint8_t ff){ uint8_t a; uint32_t b; uint8_t k = 0; uint8_t r = 7; if(f[6]=='/'){ a = ((f[4]- '0') *10)+f[5]-'0'; if(a!=5){ F85(8); return; } }else{ F85(2); return; } for(uint8_t i = 7; i<ff; i++){ if(f[i+1]==':'){ k=i; break; } } char c[(k-r)+2]; for(uint8_t i=0; i<(k-r)+1; i++){ c[i]=f[r+i]; } c[(k-r)+1] = '\0';  b = atof(c); int d = floor(b); int e[1] = { static_cast<int>(d) }; F25(e,1); F12[0] = f[ff - 2]; F12[1] = f[ff - 3]; if(F13[1] == F12[1] && F13[0] == F12[0]){ F39(b); }else{ F85(4); } } void jm4a_cmini::F38(uint8_t f,uint8_t ff) { if(f==1){ F06[0]=true; F07[0]=true; F05[0]=true; }else{ F06[1]=true; F07[1]=true; F05[1]=true; } uint8_t a = 0; switch(ff) { case 1: a = (1 << CS02) | (1 << CS00); break; case 2: a = (1 << CS02); break; case 3: a = (1 << CS01) | (1 << CS00); break; case 4: a = (1 << CS01); break; case 5: a = (1 << CS00); break; default: a = (1 << CS01) | (1 << CS00); break; } TCCR0A = 0; TCCR0B = 0; TCNT0  = 0; TCCR0A = (1 << WGM00) | (1 << WGM01); TCCR0B = a; F36(f,0.0); } void jm4a_cmini::F39(uint32_t f) { if(!F06[2]){ F85(7); return; } uint32_t a = 16000000UL / (F20 * 2UL);       uint32_t b = 16000000UL / (F20 * 65536UL);     if(f > a || f < b) { enableMFDPO(5,f); OCR1A = ICR1 / 2; return; } uint32_t c = (16000000UL / (F20 * f)) - 1; TCNT1 = 0;  ICR1 = c; F19 = c; OCR1A = ICR1 / 2;    } void jm4a_cmini::enableMFDPO(uint8_t f, uint32_t ff) { if(f != 5){ F85(9); return; } F06[2]=true; F05[2]=true; uint16_t a[] = {1, 8, 64, 256, 1024}; uint8_t b[] = { (1 << CS10),                    (1 << CS11),                     ((1 << CS11) | (1 << CS10)),       (1 << CS12),                    ((1 << CS12) | (1 << CS10))       }; uint8_t c = 0; uint32_t d = 0; for (uint8_t i = 0; i < 5; i++) { d = (16000000UL / (a[i] * ff)) - 1; if (d <= 65535) { c = i; break; } } if (d > 65535) { d = 65535; } if (a[c] == F20 && F19 == d) { return;  } F19 = d;   F20 = a[c]; TCCR1A = 0; TCCR1B = 0; TCCR1A = (1 << COM1A1) | (1 << WGM11);              TCCR1B = (1 << WGM13) | (1 << WGM12) | b[c]; TCNT1 = 0; ICR1 = d; } void jm4a_cmini::enableOMDPO(uint8_t f, uint8_t ff) { if(f !=1 && f !=2){ F85(10); return; } F38(f,ff); } void jm4a_cmini::setAnalogInput(uint8_t f, uint8_t ff) { if (f >= 0 && f <= 3) { F04[f] = true; F03[f] = ff; } else if (f >= 4 && f <= 5) { F03[f] = ff; } else { F33("-0xC03 Error: Analog input pin index out of range"); } } void jm4a_cmini::setAnalogOutput(uint8_t f) { if (f >= 0 && f <= 2) { F05[f] = true; } else { F33("-0xC04 Error: Analog output pin index out of range"); } } void jm4a_cmini::noInputs(bool f) { F16 = f; } void jm4a_cmini::noOutputs(bool f) { F17 = f; } void jm4a_cmini::setID(char f) { if (isalpha(f)) { F21 = f; } else { F33("-0xC05 Error: id non alphabetic"); } } void jm4a_cmini::setConfirmation(bool f) { F18 = f; } void jm4a_cmini::F85(uint8_t p) { switch (p) { case 0:{ F33("!JM4Automation: Configuration for Controllino Mini/Arduino Nano/ATMEGA328P-AU"); return; } case 1:{ F33("-0xA00 Error: invalid data"); return; } case 2:{ F33("-0xA01 Error: data format error"); return; } case 3:{ F33("-0xA02 Error: incomplete data"); return; } case 4:{ F33("-0xA03 Error: CRC not match"); return; } case 5:{ F33("-0xB01 Error: indefinite function"); return; } case 6:{ F33("-0xB02 Error: output not available for fast pwm"); return; } case 7:{ F33("-0xB03 Error: PWM mode is disabled for this output"); return; } case 8:{ F33("-0xC01 Error: output not available for modifiable frequency"); return; } case 9:{ F33("-0xD01 Error: output without MFD PWM signal available"); return; } case 10:{ F33("-0xD02 Error: output without OMD PWM signal available"); return; } } } 